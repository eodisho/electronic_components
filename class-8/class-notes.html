<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
    <title>class-notes.rst</title>
    <style type="text/css">

/*
   :Author: David Goodger (goodger@python.org)
   :Id: $Id: html4css1.css 7952 2016-07-26 18:15:59Z milde $
   :Copyright: This stylesheet has been placed in the public domain.

   Default cascading style sheet for the HTML output of Docutils.

   See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
   customize this style sheet.
 */

/* used to remove borders from tables and images */
body {
  background: #202020;
  color: #FFFF00;
}

.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
   dl.docutils dt {
     font-weight: bold }
 */

   div.abstract {
     margin: 2em 5em }

 div.abstract p.topic-title {
   font-weight: bold ;
   text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
   div.compound .compound-first, div.compound .compound-middle {
     margin-bottom: 0.5em }

 div.compound .compound-last, div.compound .compound-middle {
   margin-top: 0.5em }
 */

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  background: #202020;
  color: #84F5D3;
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #202020 }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

    </style>
  </head>
  <body>
    <div class="document">


      <div class="section" id="class-8-programming-the-hard-way">
        <h1>Class 8: Programming the Hard Way</h1>
        <p>How does the ATmega328P actually get programmed?  We know the chip has instructions to load data, and we know that the data electrically comes over the USB &lt;-&gt; FTDI interface.  The programmins is based on SPI, Serial Peripheral Interface bus.  We know that the data is clocked in, and it is made up of packets, each packet will contain some kind of informatiton like command, address, data.</p>
        <p>Something like:</p>
        <pre class="code literal-block">
Serial.write(&lt;cmd&gt;, &lt;addr high&gt;, &lt;addr low&gt;, &lt;data high&gt;, &lt;data low&gt;)
Serial.write( 0xAA,  0xC5         0x5C,       0xFF,        0x00     )
        </pre>
        <p>In order for USB -&gt; Serial interface to program the chip, what needs to happen?</p>
        <p>ATmega Datasheet:</p>
        <dl class="docutils">
          <dt>30.3.2. BLS – Boot Loader Section</dt>
          <dd>While the Application section is used for storing the application code, the Boot Loader software must be located in the BLS since the SPM instruction can initiate a programming when executing from the BLS only. The SPM instruction can access the entire Flash, including the BLS itself. The protection level for the Boot Loader section can be selected by the Boot Loader Lock bits (Boot Lock bits 1).</dd>
          <dt>SPM - Store Program Memory</dt>
          <dd>SPM can be used to erase a page in the Program memory, to write a page in the Program memory (that is already erased), and to set Boot Loader Lock bits.
          <a class="reference external" href="http://ww1.microchip.com/downloads/en/devicedoc/atmel-0856-avr-instruction-set-manual.pdf">AVR Instruction Set Manual 116.1</a></dd>
          <dt>16-bit op-code</dt>
          <dd><table border="1" class="first last docutils">
            <colgroup>
              <col width="25%" />
              <col width="25%" />
              <col width="25%" />
              <col width="25%" />
            </colgroup>
            <tbody valign="top">
              <tr><td>1001</td>
                <td>0101</td>
                <td>1110</td>
                <td>1000</td>
              </tr>
            </tbody>
          </table>
          </dd>
          <dt>30.6. Entering the Boot Loader Program</dt>
          <dd>Entering the Boot Loader takes place by a <strong>jump or call</strong> from the <strong>application program</strong>. This may be initiated
          by a trigger such as a command <strong>received via USART, or SPI interface</strong>. Alternatively, the Boot Reset Fuse
          can be programmed so that <strong>the Reset Vector is pointing to the Boot Flash start address after a reset</strong>. In
          this case, the Boot Loader is started after a reset. After the application code is loaded, the program can
          start executing the application code. The fuses cannot be changed by the MCU itself. This means that
          <strong>once the Boot Reset Fuse is programmed, the Reset Vector will always point to the Boot Loader Reset
            and the fuse can only be changed through the serial or parallel programming interface</strong>.</dd>
          <dt>Reset Vector</dt>
          <dd>The address to which the program will jump on a &quot;Reset Interrupt,&quot; &quot;Reset Event.&quot; etc.  not technically an interrupt, but...resetting pretty much interrupts everything whatever.</dd>
        </dl>
        <p>For example, put the boot loaded address location in the register labelled Reset Vector.  See Datasheet section 16. Interrupts for more information on vectors.</p>
        <dl class="docutils">
          <dt>30.8. Self-Programming the Flash</dt>
          <dd>The program memory is updated in a page by page fashion. Before programming a page with the data
          stored in the temporary page buffer, the page must be erased. The temporary page buffer is filled one
          word at a time using SPM and the buffer can be filled either before the Page Erase command or between
          a Page Erase and a Page Write operation</dd>
          <dt>30.8.2. Filling the Temporary Buffer (Page Loading)</dt>
          <dd><p class="first">To write an instruction word:</p>
          <ol class="arabic simple">
            <li>set up the <strong>address in the Z-pointer</strong> and</li>
            <li><strong>data in [R1:R0]</strong></li>
            <li>write “0x00000001” to SPMCSR and execute SPM <strong>within four clock cycles</strong> after writing SPMCSR.</li>
          </ol>
          <p>The content of PCWORD([Z5:Z1]) in the Z-register is used to address the data in the temporary buffer.</p>
          <p>It is not possible to write more than one time to each address without erasing the temporary buffer.</p>
          <p class="last">If the EEPROM is written in the middle of an SPM Page Load operation, all data loaded will be lost.</p>
          </dd>
          <dt>31.8. Serial Downloading</dt>
          <dd>Both the Flash and EEPROM memory arrays can be programmed using the <strong>serial SPI bus</strong> while <strong>RESET</strong>
          is pulled to <strong>GND</strong>. The serial interface consists of pins <strong>SCK, MOSI (input) and MISO (output)</strong>. After
          <strong>RESET is set low</strong>, the <strong>Programming Enable instruction</strong> needs to be executed first before program/erase
          operations can be executed.</dd>
          <dt>31.8.1 Serial Programming Pin Mapping</dt>
          <dd>A mini interface!</dd>
          <dt>31.8.2 Serial Programming Algorithm</dt>
          <dd>A mini program!</dd>
          <dt>31.8.3 Serial Programming Instruction Set</dt>
          <dd>A mini language!</dd>
        </dl>
        <div class="section" id="what">
          <h2>What?</h2>
          <ol class="arabic simple">
            <li>Plug some wire into some pins</li>
            <li>1s and 0s come over the SPI bus, a two wire interface, into MISO and MOSI</li>
            <li>That data is intepretted via the algorithm to correspond to the instructions used to load program memory.</li>
          </ol>
          <p>Not complicated at all.</p>
        </div>
      </div>
      <div class="section" id="avr-dude">
        <h1>AVR Dude</h1>
        <p>uh, ok...</p>
        <div class="section" id="how">
          <h2>How?</h2>
          <dl class="docutils">
            <dt>AVR Dude</dt>
            <dd>AVR Downloader Uploader</dd>
          </dl>
          <p>Let's use output form Arduino IDE as the first stab at this thing.</p>
          <p>Turn on &quot;File / preferences / Show verbose output during:&quot; tick both</p>
          <div class="section" id="compile-empty-program-sketch-with-verbose-output">
            <h3>Compile Empty Program(sketch) with Verbose Output</h3>
            <pre class="code literal-block">
void setup() {
    // put your setup code here, to run once:
}

void loop() {
// put your main code here, to run repeatedly:
}
            </pre>
            <p>This is totally empty.  What microcontrollar can this run on?  More specifically, how many?  More than 1?  What if they have different instruction sets?</p>
            <pre class="literal-block">
$ arduino
-builder -dump-prefs
-logger=machine
-hardware /hardware
-hardware /home/marcidy/.arduino15/packages
-hardware /home/marcidy/Arduino/hardware
-tools /tools
-builder
-tools /hardware/tools/avr
-tools /home/marcidy/.arduino15/packages
-built-in
-libraries /libraries
-libraries /home/marcidy/Arduino/libraries
-fqbn=SparkFun:avr:promicro:cpu=8MHzatmega32U4
-ide-version=10802
-build-path /tmp/arduino_build_204514 -warnings=all
-build-cache /tmp/arduino_cache_615219
-prefs=build.warn_data_percentage=75
-prefs=runtime.tools.arduinoOTA.path=/home/marcidy/.arduino15/packages/arduino/tools/arduinoOTA/1.1.1
-prefs=runtime.tools.avrdude.path=/home/marcidy/.arduino15/packages/arduino/tools/avrdude/6.3.0-arduino9
-prefs=runtime.tools.avr-gcc.path=/home/marcidy/.arduino15/packages/arduino/tools/avr-gcc/4.9.2-atmel3.5.4-arduino2
-verbose
/tmp/untitled442549665.tmp/sketch_may29a/sketch_may29a.ino

$ arduino
-builder -compile -logger=machine
-hardware /hardware
-hardware /home/marcidy/.arduino15/packages
-hardware /home/marcidy/Arduino/hardware
-tools /tools
-builder
-tools /hardware/tools/avr
-tools /home/marcidy/.arduino15/packages
-built-in
-libraries /libraries
-libraries /home/marcidy/Arduino/libraries
-fqbn=SparkFun:avr:promicro:cpu=8MHzatmega32U4 -ide-version=10802
-build-path /tmp/arduino_build_204514 -warnings=all
-build-cache /tmp/arduino_cache_615219
-prefs=build.warn_data_percentage=75
-prefs=runtime.tools.arduinoOTA.path=/home/marcidy/.arduino15/packages/arduino/tools/arduinoOTA/1.1.1
-prefs=runtime.tools.avrdude.path=/home/marcidy/.arduino15/packages/arduino/tools/avrdude/6.3.0-arduino9
-prefs=runtime.tools.avr-gcc.path=/home/marcidy/.arduino15/packages/arduino/tools/avr-gcc/4.9.2-atmel3.5.4-arduino2
-verbose
/tmp/untitled442549665.tmp/sketch_may29a/sketch_may29a.ino
            </pre>
            <p>Using board 'promicro' from platform in folder: /home/marcidy/.arduino15/packages/SparkFun/hardware/avr/1.1.7</p>
            <p>Using core 'arduino' from platform in folder: /home/marcidy/.arduino15/packages/arduino/hardware/avr/1.6.20</p>
            <p>Detecting libraries used...</p>
            <pre class="literal-block">
$ &quot;/home/marcidy/.arduino15/packages/arduino/tools/avr-gcc/4.9.2-atmel3.5.4-arduino2/bin/avr-g++&quot;
-c -g -Os -w -std=gnu++11
-fpermissive
-fno-exceptions
-ffunction-sections
-fdata-sections
-fno-threadsafe-statics
-flto -w -x c++ -E -CC
-mmcu=atmega32u4
-DF_CPU=8000000L
-DARDUINO=10802
-DARDUINO_AVR_PROMICRO
-DARDUINO_ARCH_AVR
-DUSB_VID=0x1b4f
-DUSB_PID=0x9204 '
-DUSB_MANUFACTURER=&quot;Unknown&quot;' '
-DUSB_PRODUCT=&quot;SparkFun Pro Micro&quot;'
&quot;-I/home/marcidy/.arduino15/packages/arduino/hardware/avr/1.6.20/cores/arduino&quot;
&quot;-I/home/marcidy/.arduino15/packages/SparkFun/hardware/avr/1.1.7/variants/promicro&quot;
&quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp&quot;
-o &quot;/dev/null&quot;
            </pre>
            <p>Generating function prototypes...</p>
            <pre class="literal-block">
$ &quot;/home/marcidy/.arduino15/packages/arduino/tools/avr-gcc/4.9.2-atmel3.5.4-arduino2/bin/avr-g++&quot;
-c -g -Os -w -std=gnu++11
-fpermissive
-fno-exceptions
-ffunction-sections
-fdata-sections
-fno-threadsafe-statics
-flto -w -x c++ -E -CC
-mmcu=atmega32u4
-DF_CPU=8000000L
-DARDUINO=10802
-DARDUINO_AVR_PROMICRO
-DARDUINO_ARCH_AVR
-DUSB_VID=0x1b4f
-DUSB_PID=0x9204 '
-DUSB_MANUFACTURER=&quot;Unknown&quot;' '
-DUSB_PRODUCT=&quot;SparkFun Pro Micro&quot;'
&quot;-I/home/marcidy/.arduino15/packages/arduino/hardware/avr/1.6.20/cores/arduino&quot;
&quot;-I/home/marcidy/.arduino15/packages/SparkFun/hardware/avr/1.1.7/variants/promicro&quot;
&quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp&quot;
-o &quot;/tmp/arduino_build_204514/preproc/ctags_target_for_gcc_minus_e.cpp&quot;
            </pre>
            <pre class="literal-block">
$ &quot;/tools-builder/ctags/5.8-arduino11/ctags&quot;
-u --language
-force=c++
-f - --c++-kinds=svpf
--fields=KSTtzns --line-directives
&quot;/tmp/arduino_build_204514/preproc/ctags_target_for_gcc_minus_e.cpp&quot;
            </pre>
            <p>Compiling sketch...</p>
            <pre class="literal-block">
$ &quot;/home/marcidy/.arduino15/packages/arduino/tools/avr-gcc/4.9.2-atmel3.5.4-arduino2/bin/avr-g++&quot;
-c -g -Os -Wall -Wextra -std=gnu++11
-fpermissive
-fno-exceptions
-ffunction-sections
-fdata-sections
-fno-threadsafe-statics -MMD
-flto -mmcu=atmega32u4
-DF_CPU=8000000L
-DARDUINO=10802
-DARDUINO_AVR_PROMICRO
-DARDUINO_ARCH_AVR
-DUSB_VID=0x1b4f
-DUSB_PID=0x9204 '
-DUSB_MANUFACTURER=&quot;Unknown&quot;' '
-DUSB_PRODUCT=&quot;SparkFun Pro Micro&quot;'
&quot;-I/home/marcidy/.arduino15/packages/arduino/hardware/avr/1.6.20/cores/arduino&quot;
&quot;-I/home/marcidy/.arduino15/packages/SparkFun/hardware/avr/1.1.7/variants/promicro&quot;
&quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp&quot;
-o &quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp.o&quot;
            </pre>
            <p>Compiling libraries...</p>
            <p>Compiling core...</p>
            <p>Using precompiled core</p>
            <p>Linking everything together...</p>
            <pre class="literal-block">
$ &quot;/home/marcidy/.arduino15/packages/arduino/tools/avr-gcc/4.9.2-atmel3.5.4-arduino2/bin/avr-gcc&quot;
-Wall -Wextra -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections
-mmcu=atmega32u4
-o &quot;/tmp/arduino_build_204514/sketch_may29a.ino.elf&quot;
&quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp.o&quot;
&quot;/tmp/arduino_build_204514/../arduino_cache_615219/core/core_SparkFun_avr_promicro_cpu_8MHzatmega32U4_af422d297eac2f8364c1557e6fc14ae0.a&quot;
&quot;-L/tmp/arduino_build_204514&quot;
-lm
            </pre>
            <pre class="literal-block">
$ &quot;/home/marcidy/.arduino15/packages/arduino/tools/avr-gcc/4.9.2-atmel3.5.4-arduino2/bin/avr-objcopy&quot;
-O ihex
-j .eeprom
--set-section -flags=.eeprom=alloc,load
--no-change-warnings --change-section-lma .eeprom=0
&quot;/tmp/arduino_build_204514/sketch_may29a.ino.elf&quot;
&quot;/tmp/arduino_build_204514/sketch_may29a.ino.eep&quot;
            </pre>
            <pre class="literal-block">
$ &quot;/home/marcidy/.arduino15/packages/arduino/tools/avr-gcc/4.9.2-atmel3.5.4-arduino2/bin/avr-objcopy&quot;
-O ihex
-R .eeprom
&quot;/tmp/arduino_build_204514/sketch_may29a.ino.elf&quot;
&quot;/tmp/arduino_build_204514/sketch_may29a.ino.hex&quot;
            </pre>
            <p>Sketch uses 3616 bytes (12%) of program storage space. Maximum is 28672 bytes.
            Global variables use 149 bytes (5%) of dynamic memory, leaving 2411 bytes for local variables. Maximum is 2560 bytes.</p>
          </div>
          <div class="section" id="breakdown">
            <h3>Breakdown</h3>
            <div class="section" id="tasks">
              <h4>Tasks</h4>
              <dl class="docutils">
                <dt>arduino Dump-perfs</dt>
                <dd>grabbing preferences set in the application</dd>
                <dt>arduino Compile</dt>
                <dd>gathering data about the arduino file / project</dd>
                <dt>Detecting libraries</dt>
                <dd>determining which native and user libraries need to be included</dd>
                <dt>Generating Function Prototypes</dt>
                <dd>Function prototypes are what go in &quot;.h&quot; or header files.  They are &quot;declarations&quot; of the funtion.  We don't write them in &quot;sketches&quot; so they must be constructed before true compilation.</dd>
                <dt>Compiling Sketch</dt>
                <dd>Actually compiling the code in the coding sense.</dd>
                <dt>Compiling Core</dt>
                <dd>This is compiling the code that is specific to the core used.  The core is the microcontroller architecture.  Different Arduinos may use the same microcontroller, and even similar microcontrollers may use the same core.</dd>
                <dt>Linking</dt>
                <dd>Linking is when all the different conpile code is brought together, and al lthe symbols are matched in all the files to their sources.  For example, if I defined &quot;function_beta&quot; in &quot;beta.h&quot; but use it in &quot;neat.cpp&quot;, I need to &quot;link&quot; the &quot;symbol&quot; &lt;function_beta&gt; to it's definition, probably in &quot;beta.cpp&quot;</dd>
              </dl>
            </div>
            <div class="section" id="commands">
              <h4>Commands</h4>
              <ul class="simple">
                <li>arduino</li>
                <li>avr-g++</li>
                <li>avr-gcc</li>
                <li>avr-objcopya</li>
              </ul>
              <p>These commands are the &quot;avr&quot; counterparts to the non-avr commands we find in all programming environments.  They do the same thigns, just by targetting avr specifics.</p>
              <p>There's a lot going on but a lot if it you don't need to know right now.</p>
              <dl class="docutils">
                <dt><strong>arduino</strong></dt>
                <dd><ul class="first last simple">
                  <li>Look at the &quot;-tools&quot; &quot;-hardware&quot; and &quot;-libraries&quot; flags.  Very useful information to get an idea of what is happening and where it's happening.</li>
                  <li><dl class="first docutils">
                      <dt>note the final path: &quot;/tmp/.../&quot;  that's where stuff will be stored related to this compilation. DEFINITELY LOOK IN THIS PATH</dt>
                      <dd><ul class="first last">
                        <li>why?  cool stuff!  we'll see below.</li>
                      </ul>
                      </dd>
                    </dl>
                  </li>
                  <li>who wants to take a stab at fqbn ?  F Q * N ?</li>
                </ul>
                </dd>
                <dt><strong>avr-g++</strong></dt>
                <dd><ul class="first last simple">
                  <li>&quot;g++&quot; gnu c plus plus compilier</li>
                  <li>autogenerates some code and compiles the sketch</li>
                  <li>mmcu=atmega32u4</li>
                  <li>f&lt;whatever&gt; eh, look it up.</li>
                  <li>-D ...hey, DF_CPU=8000000L ?</li>
                  <li>-D ARDUINO_AVR_PROMICRO</li>
                  <li>-D ARDUINO_ARCH_AVR</li>
                  <li><dl class="first docutils">
                      <dt>-D USB_VID=0x1b4f</dt>
                      <dd><ul class="first last">
                        <li>What's this?</li>
                      </ul>
                      </dd>
                    </dl>
                  </li>
                  <li><dl class="first docutils">
                      <dt>-D USB_PID=0x9204</dt>
                      <dd><ul class="first last">
                        <li>and this?</li>
                      </ul>
                      </dd>
                    </dl>
                  </li>
                  <li>-o means &quot;the next label is the output file&quot;</li>
                  <li>pre-processes the actual cpp file...leaves it somewhere in tmp!</li>
                </ul>
                </dd>
                <dt><strong>avr-gcc</strong></dt>
                <dd><ul class="first last simple">
                  <li>&quot;gcc&quot; gnu c compiler</li>
                  <li>elf file!</li>
                  <li>.o (object files) .a (archive files) &quot;places where code i need are&quot;</li>
                </ul>
                </dd>
                <dt><strong>avr-objcopy</strong></dt>
                <dd><ul class="first last simple">
                  <li>hex? eeprom? elf? eep?</li>
                  <li>EEP!</li>
                </ul>
                </dd>
              </dl>
              <div class="line-block">
                <div class="line"><br /></div>
              </div>
              <img alt="img/dmesg.png" src="img/dmesg.png" />
              <div class="line-block">
                <div class="line"><br /></div>
              </div>
              <img alt="img/port.png" src="img/port.png" />
            </div>
          </div>
          <div class="section" id="program">
            <h3>Program</h3>
            <pre class="literal-block">
$ avrdude
-Cavrdude.conf -v
-patmega32u4
-cavr109
-P/dev/ttyACM0
-b57600
-D
-Uflash:w:/tmp/arduino_build_204514/sketch_may29a.ino.hex:i
            </pre>
            <p>Typing the above on the commandline will program your microcontroller the exact same way the IDE did it.</p>
            <pre class="literal-block">
-C : some configuration file
-p : microcontroller core
-c : programmer id
-P : port
-b : baud rate for serial communication
-D : disable auto-erase for flash
-U : see below
            </pre>
            <p>Most options are fairly obvious or simple, but -U is fairly special.  from the documentation:</p>
            <pre class="literal-block">
-U memtype:op:filename[:format]
            </pre>
            <p></p>
            <blockquote>
              <em>Perform a memory operation. Multiple ‘-U’ options can be specified in order to operate on multiple memories on the same command-line invocation. The memtype field specifies the memory type to operate on. Use the ‘-v’ option on the command line or the part command from terminal mode to display all the memory types supported by a particular device. Typically, a device’s memory configuration at least contains the memory types flash and eeprom.</em></blockquote>
            <p>memtype can be:</p>
            <pre class="literal-block">
eeprom
flash
fuses
locks
boot
... others
            </pre>
            <p>op can be:</p>
            <pre class="literal-block">
r - read
w - write
v - verify
            </pre>
            <p>filename - name of file to be read</p>
            <p>format - optional</p>
            <pre class="literal-block">
i - intel hex
s - Motorolla S-recod
r - raw binary
e - ELF (executable and Linkable Format)
m - immediate, actual byte values
a - autodetect
            </pre>
            <p>output formats (used with read op)</p>
            <pre class="literal-block">
d - decimal
h - hex ('0x'n)
o - octal ('o'n)
b - binary ('0b'n)
            </pre>
            <p>special</p>
            <pre class="literal-block">
-v - enable verbosity, move -v, more verbose
-V - disable automatic verify
            </pre>
            <p>Using '-U' with combinations of the above, different memories of the chip can be accessed and written.</p>
          </div>
        </div>
        <div class="section" id="going-further">
          <h2>Going Further</h2>
          <p>Using this one line, outside the ide, will get you far, however, the other ones, the compiling ones, are where it really starts to get tricky.  Let's do a very simplie twi example.</p>
          <pre class="literal-block">
#include &quot;Wire.h&quot;

void setup() {
  // put your setup code here, to run once:
  Wire.begin();

}

void loop() {
  // put your main code here, to run repeatedly:

  Wire.write(&quot;Hi!&quot;);
  Wire.requestFrom(1,1);
  char c = Wire.read();
  delay(1000);

}
          </pre>
          <p>Compile..</p>
          <p>Detecting libraries used...</p>
          <pre class="literal-block">
$ avr-g++
&lt;same stuff&gt;
&quot;-I/arduino/hardware/avr/1.6.20/libraries/Wire/src&quot;
&quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp&quot;
-o &quot;/dev/null&quot;
          </pre>
          <p>Using cached library dependencies for file: /arduino/hardware/avr/1.6.20/libraries/Wire/src/Wire.cpp</p>
          <p>Using cached library dependencies for file: /arduino/hardware/avr/1.6.20/libraries/Wire/src/utility/twi.c</p>
          <p>Generating function prototypes...</p>
          <pre class="literal-block">
$ avr-g++
&lt;same stuff&gt;
&quot;-I/home/marcidy/.arduino15/packages/arduino/hardware/avr/1.6.20/libraries/Wire/src&quot;
&quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp&quot;
-o &quot;/tmp/arduino_build_204514/preproc/ctags_target_for_gcc_minus_e.cpp&quot;
          </pre>
          <p>Compiling sketch...</p>
          <pre class="literal-block">
$ avr-g++
&quot;-I/home/marcidy/.arduino15/packages/arduino/hardware/avr/1.6.20/libraries/Wire/src&quot;
&quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp&quot;
-o &quot;/tmp/arduino_build_204514/sketch/sketch_may29a.ino.cpp.o&quot;
          </pre>
          <p>Compiling libraries...</p>
          <p>Compiling library &quot;Wire&quot;</p>
          <p>Using previously compiled file: /tmp/arduino_build_204514/libraries/Wire/Wire.cpp.o</p>
          <p>Using previously compiled file: /tmp/arduino_build_204514/libraries/Wire/utility/twi.c.o</p>
          <p>Compiling core...</p>
          <p>Using precompiled core</p>
          <p>Linking everything together...</p>
          <pre class="literal-block">
$ avr-gcc
&lt;same stuff&gt;
&quot;/tmp/arduino_build_204514/libraries/Wire/utility/twi.c.o&quot;
&quot;/tmp/arduino_build_204514/../arduino_cache_615219/core/core_SparkFun_avr_promicro_cpu_8MHzatmega32U4_af422d297eac2f8364c1557e6fc14ae0.a&quot;
&quot;-L/tmp/arduino_build_204514&quot;
-lm
          </pre>
          <p>By including that library, all these new lines are required.  there are ways to handle this, called Makefiles, and are available on the web, but that's required to make a nice tool to handle this outside the ide.</p>
          <p>To truly break free, you also need to move to c++ completely, no more .ino files.  You need to write the .h and .cpp files directly.  It's not hard, but it's more to learn.</p>
          <dl class="docutils">
            <dt>avr-objdump</dt>
            <dd>You can take the elf file and convert it to a mixture of assembly and code.  This is an excellent way to learn both how the code is compiled down to assembly without learning the intermediate steps, and also what the assembly does since you can map it back to your intention.</dd>
          </dl>
        </div>
      </div>
    </div>
  </body>
</html>
